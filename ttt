#!/bin/bash

# Simple terminal todo application
# Usage: ttt

# Data file to store tasks
DATA_DIR="$HOME/.ttt"
TASKS_FILE="$DATA_DIR/tasks.txt"

# Create data directory if it doesn't exist
mkdir -p "$DATA_DIR"
touch "$TASKS_FILE"

# Colors and formatting
RESET="\033[0m"
BOLD="\033[1m"
STRIKETHROUGH="\033[9m"
ITALIC="\033[3m"
GREEN="\033[32m"
YELLOW="\033[33m"
BLUE="\033[34m"
RED="\033[31m"
CYAN="\033[36m"
GRAY="\033[37m"

# Function to display usage
show_help() {
  echo -e "${BOLD}Terminal Todo Tracker (ttt)${RESET}"
  echo -e "\n${BOLD}Commands:${RESET}"
  echo -e "  ${CYAN}ttt${RESET}              Show task list"
  echo -e "  ${CYAN}ttt add${RESET}          Add a new task"
  echo -e "  ${CYAN}ttt clear${RESET}        Clear completed tasks"
  echo -e "  ${CYAN}ttt help${RESET}         Show this help message"
  echo -e "\n${BOLD}Keyboard Shortcuts:${RESET}"
  echo -e "  ${GREEN}d${RESET} - Mark as done"
  echo -e "  ${YELLOW}p${RESET} - Postpone (enter new due date)"
  echo -e "  ${RED}n${RESET} - Remove task (not required)"
  echo -e "  ${BLUE}a${RESET} - Add new task"
  echo -e "  ${GRAY}q${RESET} - Quit application"
}

# Function to display tasks
display_tasks() {
  clear
  echo -e "\n${BOLD}${CYAN}==== Terminal Todo Tracker ====${RESET}\n"
  
  # Get unique dates and sort them
  local dates=$(grep -v "^DONE:" "$TASKS_FILE" | cut -d'|' -f2 | sort -u)
  
  # Display active tasks by date
  if [ -z "$dates" ]; then
    echo -e "${YELLOW}No active tasks.${RESET}"
  else
    echo -e "${BOLD}ACTIVE TASKS:${RESET}\n"
    local task_num=1
    
    for date in $dates; do
      echo -e "${BOLD}${CYAN}Due: $date${RESET}"
      echo -e "${GRAY}----------------------------------------${RESET}"
      
      grep "|$date|" "$TASKS_FILE" | grep -v "^DONE:" | while IFS='|' read -r status date task; do
        echo -e " ${BOLD}${BLUE}[$task_num]${RESET} $task"
        task_num=$((task_num + 1))
      done
      echo ""
    done
    
    echo -e "${GRAY}${ITALIC}----------------------------------------${RESET}"
    echo -e "${ITALIC}${BOLD}Actions:${RESET}${ITALIC} Select task number, then choose:${RESET}"
    echo -e "${ITALIC} ${GREEN}d${RESET}${ITALIC}-Done  ${YELLOW}p${RESET}${ITALIC}-Postpone  ${RED}n${RESET}${ITALIC}-Not Required  ${BLUE}a${RESET}${ITALIC}-Add New  ${GRAY}q${RESET}${ITALIC}-Quit${RESET}\n"
    echo -e "${GRAY}${ITALIC}----------------------------------------${RESET}\n"
  fi
  
  # Display completed tasks
  if grep -q "^DONE:" "$TASKS_FILE"; then
    echo -e "${BOLD}COMPLETED TASKS:${RESET}"
    echo -e "${GRAY}----------------------------------------${RESET}"
    grep "^DONE:" "$TASKS_FILE" | while IFS='|' read -r status date task; do
      echo -e " ${STRIKETHROUGH}$task${RESET} (${GRAY}completed on $date${RESET})"
    done
    echo ""
  fi
}

# Function to add a new task
add_task() {
  clear
  echo -e "\n${BOLD}${CYAN}==== Add New Task ====${RESET}\n"
  
  echo -e "${BOLD}Enter task description:${RESET} "
  read -r task
  
  echo -e "\n${BOLD}Enter due date (${YELLOW}dd/mm/yy${RESET}${BOLD}):${RESET} "
  read -r due_date
  
  # Validate date format
  if [[ ! $due_date =~ ^[0-9]{2}/[0-9]{2}/[0-9]{2}$ ]]; then
    echo -e "\n${RED}Invalid date format. Please use dd/mm/yy${RESET}"
    echo -e "Press any key to try again..."
    read -n 1
    add_task
    return
  fi
  
  echo "TODO:|$due_date|$task" >> "$TASKS_FILE"
  echo -e "\n${GREEN}Task added successfully!${RESET}"
  echo -e "Press any key to continue..."
  read -n 1
}

# Function to count tasks by status
count_tasks() {
  local active_count=$(grep -v "^DONE:" "$TASKS_FILE" | wc -l)
  local done_count=$(grep "^DONE:" "$TASKS_FILE" | wc -l)
  
  active_count=$(echo "$active_count" | tr -d ' ')
  done_count=$(echo "$done_count" | tr -d ' ')
  
  echo -e "${ITALIC}${BOLD}Status:${RESET}${ITALIC} ${BLUE}$active_count${RESET}${ITALIC} active, ${GREEN}$done_count${RESET}${ITALIC} completed${RESET}"
}

# Function to interact with tasks
interact_with_tasks() {
  display_tasks
  count_tasks
  
  # Get the list of active tasks
  local active_tasks=$(grep -v "^DONE:" "$TASKS_FILE")
  local task_count=$(echo "$active_tasks" | wc -l)
  task_count=$(echo "$task_count" | tr -d ' ')
  
  if [ "$task_count" -eq 0 ] || [ -z "$active_tasks" ]; then
    echo -e "\n${YELLOW}No tasks to interact with.${RESET}"
    echo -e "${ITALIC}Press ${BLUE}'a'${RESET}${ITALIC} to add a new task or ${GRAY}'q'${RESET}${ITALIC} to quit.${RESET}"
    read -n 1 -s choice
    case "$choice" in
      a) add_task && interact_with_tasks ;;
      q) clear && exit 0 ;;
      *) interact_with_tasks ;;
    esac
    return
  fi
  
  echo -e "\n${ITALIC}${BOLD}Enter your choice:${RESET}${ITALIC} ${RESET}"
  read -n 1 -s selection
  
  if [ "$selection" = "a" ]; then
    add_task
    interact_with_tasks
    return
  elif [ "$selection" = "q" ]; then
    clear
    exit 0
  elif [[ "$selection" =~ ^[0-9]+$ ]] && [ "$selection" -le "$task_count" ] && [ "$selection" -gt 0 ]; then
    local selected_line=$(echo "$active_tasks" | sed -n "${selection}p")
    local task_content=$(echo "$selected_line" | cut -d'|' -f3)
    
    echo -e "\n\n${BOLD}Selected:${RESET} ${CYAN}$task_content${RESET}"
    echo -e "\n${ITALIC}${BOLD}What to do with this task?${RESET}${ITALIC}"
    echo -e "${GREEN}d${RESET}${ITALIC}-Done  ${YELLOW}p${RESET}${ITALIC}-Postpone  ${RED}n${RESET}${ITALIC}-Not Required${RESET}"
    read -n 1 -s action
    
    case "$action" in
      d)
        # Mark as done
        sed -i.bak "/$selected_line/d" "$TASKS_FILE"
        echo "DONE:|$(date +%d/%m/%y)|$task_content" >> "$TASKS_FILE"
        echo -e "\n${GREEN}Task marked as done!${RESET}"
        sleep 1
        ;;
      p)
        # Postpone task
        echo -e "\n\n${BOLD}Enter new due date (${YELLOW}dd/mm/yy${RESET}${BOLD}):${RESET}"
        read -r new_date
        
        # Validate date format
        if [[ ! $new_date =~ ^[0-9]{2}/[0-9]{2}/[0-9]{2}$ ]]; then
          echo -e "\n${RED}Invalid date format. Please use dd/mm/yy${RESET}"
          sleep 2
        else
          sed -i.bak "/$selected_line/d" "$TASKS_FILE"
          echo "TODO:|$new_date|$task_content" >> "$TASKS_FILE"
          echo -e "\n${YELLOW}Task postponed to $new_date.${RESET}"
          sleep 1
        fi
        ;;
      n)
        # Not required
        echo -e "\n${RED}Are you sure you want to remove this task? (y/n)${RESET}"
        read -n 1 -s confirm
        if [ "$confirm" = "y" ]; then
          sed -i.bak "/$selected_line/d" "$TASKS_FILE"
          echo -e "\n${RED}Task removed.${RESET}"
          sleep 1
        fi
        ;;
      *)
        echo -e "\n${RED}Invalid option.${RESET}"
        sleep 1
        ;;
    esac
  else
    echo -e "\n${RED}Invalid selection.${RESET}"
    sleep 1
  fi
  
  # Clean up backup file
  rm -f "$TASKS_FILE.bak" 2>/dev/null
  
  # Show tasks again
  interact_with_tasks
}

# Function to clear completed tasks
clear_completed() {
  local done_count=$(grep "^DONE:" "$TASKS_FILE" | wc -l)
  done_count=$(echo "$done_count" | tr -d ' ')
  
  if [ "$done_count" -eq 0 ]; then
    echo -e "${YELLOW}No completed tasks to clear.${RESET}"
  else
    echo -e "${RED}Are you sure you want to clear $done_count completed tasks? (y/n)${RESET}"
    read -n 1 -s confirm
    if [ "$confirm" = "y" ]; then
      grep -v "^DONE:" "$TASKS_FILE" > "$TASKS_FILE.tmp"
      mv "$TASKS_FILE.tmp" "$TASKS_FILE"
      echo -e "${GREEN}Completed tasks cleared.${RESET}"
    else
      echo -e "${YELLOW}Operation cancelled.${RESET}"
    fi
  fi
  
  echo -e "${ITALIC}Press any key to continue...${RESET}"
  read -n 1
  interact_with_tasks
}

# Main program logic
case "$1" in
  add)
    add_task
    interact_with_tasks
    ;;
  clear)
    clear_completed
    ;;
  help)
    show_help
    ;;
  *)
    interact_with_tasks
    ;;
esac 